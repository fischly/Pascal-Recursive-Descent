
#pragma once

#include <vector>
// #include "../../common/token-enum.h"

// firstSets[START] // -> { PROGRAM }

enum NonTerminal {
    NONE = 0,
    START = 1,
    VARDEC,
    VARDECLIST,
    IDENTLISTTYPE,
    IDENTLIST,
    TYPE,
    SIMPLETYPE,
    SUBPROGLIST,
    SUBPROGHEAD,
    PARLIST,
    COMPSTMT,
    STMTLIST,
    STATEMENT,
    STATEMENT2,
    PROCCALL,
    PARAMS,
    ASSIGNSTMT,
    INDEX,
    IFSTMT,
    WHILESTMT,
    EXPRLIST,
    EXPR,
    SIMPLEEXPR,
    TERM,
    FACTOR,
    RELOP,
    ADDOP,
    MULOP
};

const std::vector<TokenType> FIRSTSETS[] = {
    [NONE] = {},
    [START] = { TokenType::PROGRAM },
    [VARDEC] = { TokenType::VAR },
    [VARDECLIST] = { TokenType::IDENTIFIER },
    [IDENTLISTTYPE] = { TokenType::IDENTIFIER },
    [IDENTLIST] = { TokenType::IDENTIFIER },
    [TYPE] = { TokenType::INTEGER, TokenType::REAL, TokenType::BOOLEAN, TokenType::ARRAY },
    [SIMPLETYPE] = { TokenType::INTEGER, TokenType::REAL, TokenType::BOOLEAN },
    [SUBPROGLIST] = { TokenType::FUNCTION, TokenType::PROCEDURE, TokenType::EPSILON },
    [SUBPROGHEAD] = { TokenType::FUNCTION, TokenType::PROCEDURE },
    [PARLIST] = { TokenType::IDENTIFIER },
    [COMPSTMT] = { TokenType::BEGIN_ },
    [STMTLIST] = { TokenType::IDENTIFIER, TokenType::IF, TokenType::WHILE, TokenType::BEGIN_ },
    [STATEMENT] = { TokenType::IDENTIFIER, TokenType::IF, TokenType::WHILE, TokenType::BEGIN_ },
    [STATEMENT2] = { TokenType::BRACKETS_OPEN, TokenType::EPSILON, TokenType::OP_ASSIGNMENT, TokenType::SQUARE_OPEN},
    [PROCCALL] = { TokenType::BRACKETS_OPEN, TokenType::EPSILON },
    [PARAMS] = { TokenType::BRACKETS_OPEN },
    [ASSIGNSTMT] = { TokenType::OP_ASSIGNMENT, TokenType::SQUARE_OPEN },
    [INDEX] = { TokenType::SQUARE_OPEN },
    [IFSTMT] = { TokenType::IF },
    [WHILESTMT] = { TokenType::WHILE },
    [EXPRLIST] = { TokenType::LITERAL_INTEGER, 
                   TokenType::LITERAL_REAL,
                   TokenType::LITERAL_FALSE,
                   TokenType::LITERAL_TRUE,
                   TokenType::OP_NOT,
                   TokenType::IDENTIFIER,
                   TokenType::OP_SUB, 
                   TokenType::BRACKETS_OPEN },
    [EXPR] = { TokenType::LITERAL_INTEGER, 
               TokenType::LITERAL_REAL,
               TokenType::LITERAL_FALSE,
               TokenType::LITERAL_TRUE,
               TokenType::OP_NOT,
               TokenType::IDENTIFIER,
               TokenType::OP_SUB, 
               TokenType::BRACKETS_OPEN },
    [SIMPLEEXPR] = { TokenType::LITERAL_INTEGER, 
                     TokenType::LITERAL_REAL,
                     TokenType::LITERAL_FALSE,
                     TokenType::LITERAL_TRUE,
                     TokenType::OP_NOT,
                     TokenType::IDENTIFIER,
                     TokenType::OP_SUB, 
                     TokenType::BRACKETS_OPEN },
    [TERM] = { TokenType::LITERAL_INTEGER, 
               TokenType::LITERAL_REAL,
               TokenType::LITERAL_FALSE,
               TokenType::LITERAL_TRUE,
               TokenType::OP_NOT,
               TokenType::IDENTIFIER,
               TokenType::OP_SUB,
               TokenType::BRACKETS_OPEN },

    [FACTOR] = { TokenType::LITERAL_INTEGER,
                 TokenType::LITERAL_REAL,
                 TokenType::LITERAL_FALSE,
                 TokenType::LITERAL_TRUE,
                 TokenType::OP_NOT,
                 TokenType::IDENTIFIER,
                 TokenType::OP_SUB,
                 TokenType::BRACKETS_OPEN },
    [RELOP] = { TokenType::OP_EQUALS,
                TokenType::OP_NOT_EQUALS,
                TokenType::OP_LESS,
                TokenType::OP_LESS_EQUAL, 
                TokenType::OP_GREATER,
                TokenType::OP_GREATER_EQUAL },
    [ADDOP] = { TokenType::OP_ADD, TokenType::OP_SUB, TokenType::OP_OR },
    [MULOP] = { TokenType::OP_MUL, TokenType::OP_DIV, TokenType::OP_INTEGER_DIV, TokenType::OP_AND }
};

const std::vector<TokenType> FOLLOWSETS[] = {
    [NONE] = {},
    [START] = {  },
    [VARDEC] = { TokenType::FUNCTION, TokenType::PROCEDURE, TokenType::BEGIN_ },
    [VARDECLIST] = { TokenType::FUNCTION, TokenType::PROCEDURE, TokenType::BEGIN_ },
    [IDENTLISTTYPE] = { TokenType::SEMICOLON, TokenType::BRACKETS_CLOSING },
    [IDENTLIST] = { TokenType::COLON },
    [TYPE] = { TokenType::SEMICOLON, TokenType::BRACKETS_CLOSING },
    [SIMPLETYPE] = { TokenType::SEMICOLON, TokenType::BRACKETS_CLOSING },
    [SUBPROGLIST] = { TokenType::BEGIN_ },
    [SUBPROGHEAD] = { TokenType::VAR, TokenType::BEGIN_ },
    [PARLIST] = { TokenType::BRACKETS_CLOSING },
    [COMPSTMT] = { TokenType::DOT, TokenType::SEMICOLON, TokenType::END_, TokenType::ELSE },
    [STMTLIST] = { TokenType::END_ },
    [STATEMENT] = { TokenType::SEMICOLON, TokenType::END_, TokenType::ELSE },
    [STATEMENT2] = { TokenType::SEMICOLON, TokenType::END_, TokenType::ELSE },
    [PROCCALL] = { TokenType::SEMICOLON, TokenType::END_, TokenType::ELSE },
    [PARAMS] = { TokenType::OP_MUL, TokenType::OP_DIV, TokenType::OP_INTEGER_DIV, TokenType::OP_AND, TokenType::OP_EQUALS, TokenType::OP_ADD,  TokenType::OP_SUB, TokenType::OP_OR, TokenType::SEMICOLON, TokenType::END_, TokenType::RANGE_DOTS, TokenType::SQUARE_CLOSING, TokenType::THEN, TokenType::DO, TokenType::BRACKETS_CLOSING, TokenType::OP_LESS, TokenType::OP_LESS_EQUAL, TokenType::OP_GREATER, TokenType::OP_GREATER_EQUAL, TokenType::OP_EQUALS, TokenType::OP_NOT_EQUALS, TokenType::ELSE },
    [ASSIGNSTMT] = { TokenType::SEMICOLON, TokenType::END_, TokenType::ELSE },
    [INDEX] = { TokenType::OP_ASSIGNMENT, TokenType::OP_MUL, TokenType::OP_DIV, TokenType::OP_INTEGER_DIV, TokenType::OP_AND, TokenType::OP_ADD, TokenType::OP_SUB, TokenType::OP_OR, TokenType::SEMICOLON, TokenType::END_, TokenType::RANGE_DOTS, TokenType::SQUARE_CLOSING, TokenType::THEN, TokenType::DO, TokenType::BRACKETS_CLOSING, TokenType::OP_LESS, TokenType::OP_LESS_EQUAL, TokenType::OP_GREATER, TokenType::OP_GREATER_EQUAL, TokenType::OP_EQUALS, TokenType::OP_NOT_EQUALS, TokenType::ELSE  },
    [IFSTMT] = { TokenType::SEMICOLON, TokenType::END_, TokenType::ELSE },
    [WHILESTMT] = { TokenType::SEMICOLON, TokenType::END_, TokenType::ELSE },
    [EXPRLIST] = { TokenType::BRACKETS_CLOSING },
    [EXPR] = { TokenType::SEMICOLON, TokenType::END_, TokenType::RANGE_DOTS, TokenType::SQUARE_CLOSING, TokenType::THEN, TokenType::DO, TokenType::BRACKETS_CLOSING, TokenType::ELSE },
    [SIMPLEEXPR] = { TokenType::SEMICOLON, TokenType::END_, TokenType::RANGE_DOTS, TokenType::SQUARE_CLOSING, TokenType::THEN, TokenType::DO, TokenType::BRACKETS_CLOSING, TokenType::OP_LESS, TokenType::OP_LESS_EQUAL, TokenType::OP_GREATER, TokenType::OP_GREATER_EQUAL, TokenType::OP_EQUALS, TokenType::OP_NOT_EQUALS, TokenType::ELSE },
    [TERM] = { TokenType::OP_ADD, TokenType::OP_SUB, TokenType::OP_OR, TokenType::SEMICOLON, TokenType::END_, TokenType::RANGE_DOTS, TokenType::SQUARE_CLOSING, TokenType::THEN, TokenType::DO, TokenType::BRACKETS_CLOSING, TokenType::OP_LESS, TokenType::OP_LESS_EQUAL, TokenType::OP_GREATER, TokenType::OP_GREATER_EQUAL, TokenType::OP_EQUALS, TokenType::OP_NOT_EQUALS, TokenType::ELSE },

    [FACTOR] = { TokenType::OP_MUL, TokenType::OP_DIV, TokenType::OP_INTEGER_DIV, TokenType::OP_AND, TokenType::OP_ADD, TokenType::OP_SUB, TokenType::OP_OR, TokenType::SEMICOLON, TokenType::END_, TokenType::RANGE_DOTS, TokenType::SQUARE_CLOSING, TokenType::THEN, TokenType::DO, TokenType::BRACKETS_CLOSING, TokenType::OP_LESS, TokenType::OP_LESS_EQUAL, TokenType::OP_GREATER, TokenType::OP_GREATER_EQUAL, TokenType::OP_EQUALS, TokenType::OP_NOT_EQUALS, TokenType::ELSE },
    [RELOP] = { TokenType::LITERAL_INTEGER, TokenType::LITERAL_REAL, TokenType::LITERAL_FALSE, TokenType::LITERAL_TRUE, TokenType::IDENTIFIER, TokenType::OP_NOT, TokenType::OP_SUB, TokenType::BRACKETS_OPEN, TokenType::ELSE },
    [ADDOP] = { TokenType::LITERAL_INTEGER, TokenType::LITERAL_REAL, TokenType::LITERAL_FALSE, TokenType::LITERAL_TRUE, TokenType::IDENTIFIER, TokenType::OP_NOT, TokenType::OP_SUB, TokenType::BRACKETS_OPEN, TokenType::ELSE },
    [MULOP] = { TokenType::LITERAL_INTEGER, TokenType::LITERAL_REAL, TokenType::LITERAL_FALSE, TokenType::LITERAL_TRUE, TokenType::IDENTIFIER, TokenType::OP_NOT, TokenType::OP_SUB, TokenType::BRACKETS_OPEN, TokenType::ELSE }
};


const char* RULE_NAMES[] = {
        [NONE] = "NONE",
        [START] = "START",
        [VARDEC] = "VARDEC",
        [VARDECLIST] = "VARDECLIST",
        [IDENTLISTTYPE] = "IDENTLISTTYPE",
        [IDENTLIST] = "IDENTLIST",
        [TYPE] = "TYPE",
        [SIMPLETYPE] = "SIMPLETYPE",
        [SUBPROGLIST] = "SUBPROGLIST",
        [SUBPROGHEAD] = "SUBPROGHEAD",
        [PARLIST] = "PARLIST",
        [COMPSTMT] = "COMPSTMT",
        [STMTLIST] = "STMTLIST",
        [STATEMENT] = "STATEMENT",
        [STATEMENT2] = "STATEMENT2",
        [PROCCALL] = "PROCCALL",
        [PARAMS] = "PARAMS",
        [ASSIGNSTMT] = "ASSIGNSTMT",
        [INDEX] = "INDEX",
        [IFSTMT] = "IFSTMT",
        [WHILESTMT] = "WHILESTMT",
        [EXPRLIST] = "EXPRLIST",
        [EXPR] = "EXPR",
        [SIMPLEEXPR] = "SIMPLEEXPR",
        [TERM] = "TERM",

        [FACTOR] = "FACTOR",
        [RELOP] = "RELOP",
        [ADDOP] = "ADDOP",
        [MULOP] = "MULOP"
};
